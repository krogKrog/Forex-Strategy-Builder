// Strategy Generator - Math
// Part of Forex Strategy Builder
// Website http://forexsb.com/
// Copyright (c) 2006 - 2011 Miroslav Popov - All rights reserved.
// This code or any part of it cannot be used in other applications without a permission.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;

namespace Forex_Strategy_Builder.Dialogs.Generator
{
    /// <summary>
    /// Strategy Generator
    /// </summary>
    public partial class Generator : Form
    {
        bool isGenerating;
        int  bestBalance;
        Strategy strategyBest;

        int lockedEntryFilters;
        int lockedExitFilters;
        int maxOpeningLogicSlots;
        int maxClosingLogicSlots;
        bool isEntryLocked; // Shows if the entry logic is locked
        bool isExitLocked;  // Shows if the exit logic is locked
        IndicatorSlot   lockedEntrySlot;    // Holds a locked entry slot.
        IndicatorSlot   lockedExitSlot;     // Holds a locked exit slot.
        IndicatorSlot[] aLockedEntryFilter; // Holds all locked entry filters.
        IndicatorSlot[] aLockedExitFilter;  // Holds all locked exit filters.

        string generatedDescription = string.Empty; // A description generated by the generator.
        bool isStrategyModified; // True if modified, false when the strategy was fully generated
        bool isStartegyChanged;

        int cycles;
        int minutes;
        int progressPercent;

        // Out of Sample
        int   barOOS = Data.Bars - 1;
        bool  isOOS  = false;
        float targetBalanceRatio = 1;

        List<string> indicatorBlackList;
        List<string> entryIndicators = new List<string>();
        List<string> entryFilterIndicators = new List<string>();
        List<string> exitIndicators = new List<string>();
        List<string> exitIndicatorsWithFilters = new List<string>();
        List<string> exitFilterIndicators = new List<string>();

        /// <summary>
        /// BtnGenerate_Click
        /// </summary>
        void BtnGenerate_Click(object sender, EventArgs e)
        {
            if (isGenerating)
            {   // Cancel the asynchronous operation
                bgWorker.CancelAsync();
            }
            else
            {   // Start the bgWorker
                PrepareStrategyForGenerating();
                CheckForLockedSlots();
                PrepareIndicatorLists();
                bool isEnoughIndicators = CheckAvailableIndicators();

                if (isEntryLocked && isExitLocked || !isEnoughIndicators)
                {
                    System.Media.SystemSounds.Hand.Play();
                    return;
                }

                Cursor = Cursors.WaitCursor;
                
                minutes = (int)nudWorkingMinutes.Value;
                progressBar.Style = minutes > 0 ? ProgressBarStyle.Blocks : ProgressBarStyle.Marquee;

                generatedDescription = String.Empty;

                foreach (Control control in pnlCommon.Controls)
                    control.Enabled = false;
                foreach (Control control in pnlLimitations.Controls)
                    control.Enabled = false;
                foreach (Control control in pnlSettings.Controls)
                    control.Enabled = false;

                indicatorsLayout.BlockIndikatorChange();

                tsbtLockAll.Enabled      = false;
                tsbtUnlockAll.Enabled    = false;
                tsbtLinkAll.Enabled      = false;
                tsbtOverview.Enabled     = false;
                tsbtStrategyInfo.Enabled = false;

                lblCalcStrInfo.Enabled = true;
                lblCalcStrNumb.Enabled = true;
                chbHideFSB.Enabled     = true;

                btnAccept.Enabled = false;
                btnCancel.Enabled = false;
                btnGenerate.Text  = Language.T("Stop");

                isGenerating      = true;

                progressBar.Value = 1;
                progressPercent   = 0;
                cycles            = 0;

                if (chbGenerateNewStrategy.Checked)
                    top10Layout.ClearTop10Slots();

                bgWorker.RunWorkerAsync();
            }

            return;
        }

        /// <summary>
        /// Does the job
        /// </summary>
        void BgWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            // Get the BackgroundWorker that raised this event
            BackgroundWorker worker = sender as BackgroundWorker;

            // Generate a strategy
            Generating(worker, e);
        }

        /// <summary>
        /// This event handler updates the progress bar.
        /// </summary>
        void BgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            progressBar.Value = e.ProgressPercentage;
        }

        /// <summary>
        /// This event handler deals with the results of the background operation
        /// </summary>
        void BgWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (!e.Cancelled && Configs.PlaySounds)
                System.Media.SystemSounds.Exclamation.Play();

            RestoreFromBest();

            Backtester.Calculate();
            Backtester.CalculateAccountStats();

            smallBalanceChart.SetChartData();
            smallBalanceChart.InitChart();
            smallBalanceChart.Invalidate();

            strategyLayout.Enabled = true;
            RebuildStrategyLayout(strategyBest);
            
            isGenerating = false;
            
            btnAccept.Enabled = true;
            btnCancel.Enabled = true;
            
            foreach (Control control in pnlCommon.Controls)
                control.Enabled = true;
            foreach (Control control in pnlLimitations.Controls)
                control.Enabled = true;
            foreach (Control control in pnlSettings.Controls)
                control.Enabled = true;

            indicatorsLayout.UnblockIndikatorChange();

            tsbtLockAll.Enabled      = true;
            tsbtUnlockAll.Enabled    = true;
            tsbtLinkAll.Enabled      = true;
            tsbtOverview.Enabled     = true;
            tsbtStrategyInfo.Enabled = true;

            btnGenerate.Text  = Language.T("Generate");
            progressBar.Style = ProgressBarStyle.Blocks;

            Cursor = Cursors.Default;

            return;
        }

        /// <summary>
        /// Prepare the strategy for generating
        /// </summary>
        void PrepareStrategyForGenerating()
        {
            lockedEntrySlot    = null;
            lockedEntryFilters = 0;
            aLockedEntryFilter = new IndicatorSlot[Math.Max(Strategy.MaxOpenFilters, strategyBest.OpenFilters)];
            lockedExitSlot     = null;
            lockedExitFilters  = 0;
            aLockedExitFilter  = new IndicatorSlot[Math.Max(Strategy.MaxCloseFilters, strategyBest.CloseFilters)];

            // Copy the locked slots
            for (int slot = 0; slot < strategyBest.Slots; slot++)
            {
                if (strategyBest.Slot[slot].SlotStatus == StrategySlotStatus.Locked ||
                    strategyBest.Slot[slot].SlotStatus == StrategySlotStatus.Linked)
                {
                    if (strategyBest.Slot[slot].SlotType == SlotTypes.Open)
                        lockedEntrySlot = strategyBest.Slot[slot];
                    else if (strategyBest.Slot[slot].SlotType == SlotTypes.OpenFilter)
                    {
                        aLockedEntryFilter[lockedEntryFilters] = strategyBest.Slot[slot];
                        lockedEntryFilters++;
                    }
                    else if (strategyBest.Slot[slot].SlotType == SlotTypes.Close)
                        lockedExitSlot = strategyBest.Slot[slot];
                    else if (strategyBest.Slot[slot].SlotType == SlotTypes.CloseFilter)
                    {
                        aLockedExitFilter[lockedExitFilters] = strategyBest.Slot[slot];
                        lockedExitFilters++;
                    }
                }
            }

            if (chbGenerateNewStrategy.Checked)
                bestBalance = 0;
            else
                bestBalance = (isOOS ? Backtester.Balance(barOOS) : Backtester.NetBalance);

            maxOpeningLogicSlots = chbMaxOpeningLogicSlots.Checked ? (int)nudMaxOpeningLogicSlots.Value: Strategy.MaxOpenFilters;
            maxClosingLogicSlots = chbMaxClosingLogicSlots.Checked ? (int)nudMaxClosingLogicSlots.Value: Strategy.MaxCloseFilters;

            return;
        }

        /// <summary>
        /// Check if all slots are locked.
        /// </summary>
        void CheckForLockedSlots()
        {
            isEntryLocked = false;
            isExitLocked  = false;

            if (lockedEntrySlot != null && lockedEntryFilters >= maxOpeningLogicSlots)
                isEntryLocked = true;

            if (lockedEntryFilters > maxOpeningLogicSlots)
                maxOpeningLogicSlots = lockedEntryFilters;

            if (lockedExitSlot != null && !Indicator_Store.ClosingIndicatorsWithClosingFilters.Contains(lockedExitSlot.IndicatorName))
                isExitLocked = true;
            else if (lockedExitSlot != null && Indicator_Store.ClosingIndicatorsWithClosingFilters.Contains(lockedExitSlot.IndicatorName) && lockedExitFilters >= maxClosingLogicSlots)
                isExitLocked = true;
            else if (lockedExitSlot == null && lockedExitFilters > 0 && lockedExitFilters >= maxClosingLogicSlots)
                isExitLocked = true;

            if (lockedExitFilters > maxClosingLogicSlots)
                maxClosingLogicSlots = lockedExitFilters;

            for (int slot = 0; slot < strategyBest.Slots; slot++)
            {
                if (strategyBest.Slot[slot].SlotStatus == StrategySlotStatus.Linked)
                {
                    if (strategyBest.Slot[slot].SlotType == SlotTypes.Open)
                        isEntryLocked = false;
                    else if (strategyBest.Slot[slot].SlotType == SlotTypes.OpenFilter)
                        isEntryLocked = false;
                    else if (strategyBest.Slot[slot].SlotType == SlotTypes.Close)
                        isExitLocked = false;
                    else if (strategyBest.Slot[slot].SlotType == SlotTypes.CloseFilter)
                        isExitLocked = false;
                }
            }

            return;
        }

        /// <summary>
        /// Prepare available indicators for each slot.
        /// </summary>
        void PrepareIndicatorLists()
        {
            // Clear lists
            entryIndicators.Clear();
            entryFilterIndicators.Clear();
            exitIndicators.Clear();
            exitIndicatorsWithFilters.Clear();
            exitFilterIndicators.Clear();

            // Copy all no banned indicators
            foreach (string indicator in Indicator_Store.OpenPointIndicators)
                if (!indicatorsLayout.IsIndicatorBanned(SlotTypes.Open, indicator))
                    entryIndicators.Add(indicator);
            foreach (string indicator in Indicator_Store.OpenFilterIndicators)
                if (!indicatorsLayout.IsIndicatorBanned(SlotTypes.OpenFilter, indicator))
                    entryFilterIndicators.Add(indicator);
            foreach (string indicator in Indicator_Store.ClosePointIndicators)
                if (!indicatorsLayout.IsIndicatorBanned(SlotTypes.Close, indicator))
                    exitIndicators.Add(indicator);
            foreach (string indicator in Indicator_Store.ClosingIndicatorsWithClosingFilters)
                if (!indicatorsLayout.IsIndicatorBanned(SlotTypes.Close, indicator))
                    exitIndicatorsWithFilters.Add(indicator);
            foreach (string indicator in Indicator_Store.CloseFilterIndicators)
                if (!indicatorsLayout.IsIndicatorBanned(SlotTypes.CloseFilter, indicator))
                    exitFilterIndicators.Add(indicator);

            // Remove special cases
            bool isPeriodDayOrWeek = Data.Period == DataPeriods.day || Data.Period == DataPeriods.week;

            if (entryIndicators.Contains("Fibonacci"))
                entryIndicators.Remove("Fibonacci");
            if (entryIndicators.Contains("Day Opening") && isPeriodDayOrWeek)
                entryIndicators.Remove("Day Opening");
            if (entryIndicators.Contains("Hourly High Low") && isPeriodDayOrWeek)
                entryIndicators.Remove("Hourly High Low");
            if (entryIndicators.Contains("Entry Hour") && isPeriodDayOrWeek)
                entryIndicators.Remove("Entry Hour");

            if (entryFilterIndicators.Contains("Random Filter"))
                entryFilterIndicators.Remove("Random Filter");
            if (entryFilterIndicators.Contains("Data Bars Filter"))
                entryFilterIndicators.Remove("Data Bars Filter");
            if (entryFilterIndicators.Contains("Date Filter"))
                entryFilterIndicators.Remove("Date Filter");
            if (entryFilterIndicators.Contains("Long or Short"))
                entryFilterIndicators.Remove("Long or Short");
            if (entryFilterIndicators.Contains("Entry Time"))
                entryFilterIndicators.Remove("Entry Time");
            if (entryFilterIndicators.Contains("Lot Limiter"))
                entryFilterIndicators.Remove("Lot Limiter");
            if (entryFilterIndicators.Contains("Hourly High Low") && isPeriodDayOrWeek)
                entryFilterIndicators.Remove("Hourly High Low");

            if (exitIndicators.Contains("Day Closing") && isPeriodDayOrWeek)
                exitIndicators.Remove("Day Closing");
            if (exitIndicators.Contains("Hourly High Low") && isPeriodDayOrWeek)
                exitIndicators.Remove("Hourly High Low");
            if (exitIndicators.Contains("Exit Hour") && isPeriodDayOrWeek)
                exitIndicators.Remove("Exit Hour");
            if (exitIndicators.Contains("Close and Reverse") && strategyBest.OppSignalAction != OppositeDirSignalAction.Reverse && strategyBest.PropertiesStatus == StrategySlotStatus.Locked)
                exitIndicators.Remove("Close and Reverse");

            if (exitIndicatorsWithFilters.Contains("Day Closing") && isPeriodDayOrWeek)
                exitIndicatorsWithFilters.Remove("Day Closing");
            if (exitIndicatorsWithFilters.Contains("Close and Reverse") && strategyBest.OppSignalAction != OppositeDirSignalAction.Reverse && strategyBest.PropertiesStatus == StrategySlotStatus.Locked)
                exitIndicatorsWithFilters.Remove("Close and Reverse");

            if (exitFilterIndicators.Contains("Random Filter"))
                exitFilterIndicators.Remove("Random Filter");
            if (exitFilterIndicators.Contains("Hourly High Low") && isPeriodDayOrWeek)
                exitFilterIndicators.Remove("Hourly High Low");
        }

        /// <summary>
        /// Checks if enough indicators are allowed
        /// </summary>
        bool CheckAvailableIndicators()
        {
            bool ok = true;

            if (!isEntryLocked && entryIndicators.Count == 0)
                ok = false;
            if (entryFilterIndicators.Count < maxOpeningLogicSlots - lockedEntryFilters)
                ok = false;
            if (!isExitLocked && exitIndicators.Count == 0)
                ok = false;
            if (!isExitLocked && exitIndicatorsWithFilters.Count == 0 && chbMaxClosingLogicSlots.Enabled && nudMaxClosingLogicSlots.Value > 0)
                ok = false;
            if (lockedExitFilters > 0 && exitIndicatorsWithFilters.Count == 0)
                ok = false;
            if (chbMaxClosingLogicSlots.Enabled && exitFilterIndicators.Count < nudMaxClosingLogicSlots.Value - lockedExitFilters)
                ok = false;
            if (!chbMaxClosingLogicSlots.Enabled && exitFilterIndicators.Count < maxClosingLogicSlots - lockedExitFilters)
                ok = false;

            return ok;
        }

        /// <summary>
        /// Generates a strategy
        /// </summary>
        void Generating(BackgroundWorker worker, DoWorkEventArgs e)
        {
            DateTime startTime = DateTime.Now;
            TimeSpan workTime  = new TimeSpan(0, minutes, 0);
            DateTime stopTime  = startTime + workTime;

            bool isStopGenerating = false;
            do
            {   // The generating cycle
                if (worker.CancellationPending)
                {   // The Generating was stopped by the user
                    e.Cancel = true;
                    isStopGenerating = true;
                }
                else if (minutes > 0 && stopTime < DateTime.Now)
                {   // The time finished
                    isStopGenerating = true;
                }
                else
                {   // The main job
                    GenerateStrategySlots();
                    GenerateSameOppSignal();
                    GeneratePermanentSL();
                    GeneratePermanentTP();
                    GenerateBreakEven();

                    // Calculates the back test.
                    bool isBetter = CalculateTheResult(false);

                    // Initial Optimization
                    if (chbInitialOptimisation.Checked)
                        PerformInitialOptimization(worker, isBetter);
                }

                if (minutes > 0)
                {
                    // Report progress as a percentage of the total task.
                    TimeSpan passedTime = DateTime.Now - startTime;
                    int percentComplete = (int)(100 * passedTime.TotalSeconds / workTime.TotalSeconds);
                    percentComplete = percentComplete > 100 ? 100 : percentComplete;
                    if (percentComplete > progressPercent)
                    {
                        progressPercent = percentComplete;
                        worker.ReportProgress(percentComplete);
                    }
                }

            } while (!isStopGenerating);

            return;
        }

        /// <summary>
        /// Calculates the generated result
        /// </summary>
        bool CalculateTheResult(bool isSaveEqualResult)
        {
            bool isBetter = false;
            cycles++;

            Data.FirstBar = Data.Strategy.SetFirstBar();
            Data.Strategy.AdjustUsePreviousBarValue();

            // Sets default logical group for all slots that are open (not locked or linked).
            foreach (IndicatorSlot slot in Data.Strategy.Slot)
                if (slot.SlotStatus == StrategySlotStatus.Open)
                    slot.LogicalGroup = Data.Strategy.GetDefaultGroup(slot.SlotNumber);

#if !DEBUG
            try
            {
#endif
                Backtester.Calculate();

                int balance = (isOOS ? Backtester.Balance(barOOS) : Backtester.NetBalance);
                bool isLimitationsOK = IsLimitationsFulfilled();

                if (isLimitationsOK)
                {
                    if (bestBalance < balance || (bestBalance == balance && (isSaveEqualResult || Data.Strategy.Slots < strategyBest.Slots)))
                    {
                        strategyBest = Data.Strategy.Clone();
                        strategyBest.PropertiesStatus = Data.Strategy.PropertiesStatus;
                        for (int slot = 0; slot < Data.Strategy.Slots; slot++)
                            strategyBest.Slot[slot].SlotStatus = Data.Strategy.Slot[slot].SlotStatus;

                        string description = GenerateDescription();
                        if (balance > bestBalance)
                            AddStrategyToGeneratorHistory(description);
                        else
                            UpdateStrategyInGeneratorHistory(description);
                        SetSrategyDescriptionButton();

                        bestBalance = balance;
                        isBetter = true;
                        isStartegyChanged = true;

                        RefreshSmallBalanceChart();
                        RefreshAccountStatisticas();
                        RebuildStrategyLayout(strategyBest);
                        Top10AddStrategy();
                    }
                    else if (top10Layout.IsNominated(balance))
                    {
                        Top10AddStrategy();
                    }
                }

                SetLabelCyclesText(cycles.ToString());
#if !DEBUG
            }
            catch (Exception exception)
            {
                string text = GenerateCalculationErrorMessage(exception.Message);
                string caption = "Strategy Calculation Error";
                ReportIndicatorError(text, caption);

                isBetter = false;
            }
#endif

            return isBetter;
        }

        /// <summary>
        /// Calculates an indicator and returns OK status.
        /// </summary>
        bool CalculateIndicator(SlotTypes slotType, Indicator indicator)
        {
            bool okStatus = false;
#if !DEBUG
            try
            {
#endif
                indicator.Calculate(slotType);
                okStatus = true;
#if !DEBUG
            }
            catch (Exception exception)
            {
                string message = "Please report this error in the support forum!";
                if (indicator.CustomIndicator)
                    message = "Please report this error to the author of the indicator!<br />" +
                        "You may remove this indicator from the Custom Indicators folder.";

                string text =
                    "<h1>Error: " + exception.Message + "</h1>" +
                    "<p>" +
                        "Slot type: <strong>" + slotType.ToString()  + "</strong><br />" +
                        "Indicator: <strong>" + indicator.ToString() + "</strong>" +
                    "</p>" +
                    "<p>" +
                        message +
                    "</p>";

                string caption = "Indicator Calculation Error";
                ReportIndicatorError(text, caption);
                indicatorBlackList.Add(indicator.IndicatorName);
                okStatus = false;
            }
#endif

            return okStatus;
        }

        /// <summary>
        /// Restores the strategy from the best one
        /// </summary>
        void RestoreFromBest()
        {
            Data.Strategy = strategyBest.Clone();
            Data.Strategy.PropertiesStatus = strategyBest.PropertiesStatus;
            for (int slot = 0; slot < strategyBest.Slots; slot++)
                Data.Strategy.Slot[slot].SlotStatus = strategyBest.Slot[slot].SlotStatus;

            RecalculateSlots();
        }

        /// <summary>
        /// Check the strategy limitations
        /// </summary>
        bool IsLimitationsFulfilled()
        {
            // The calculated strategy has higher profit
            // or the same profit but lower number of slots
            Backtester.CalculateAccountStats();

            // Limitation Max Ambiguous Bars
            if (chbAmbiguousBars.Checked && Backtester.AmbiguousBars > nudAmbiguousBars.Value)
                return false;

            // Limitation Max Equity Drawdown
            double maxEquityDrawdown = Configs.AccountInMoney ? Backtester.MaxMoneyEquityDrawdown : Backtester.MaxEquityDrawdown;
            if (chbMaxDrawdown.Checked && maxEquityDrawdown > (double)nudMaxDrawdown.Value)
                return false;

            // Limitation Max Equity percent drawdown
            if (chbEquityPercent.Checked && Backtester.MoneyEquityPercentDrawdown > (double)nudEquityPercent.Value)
                return false;

            // Limitation Min Trades
            if (chbMinTrades.Checked && Backtester.ExecutedOrders < nudMinTrades.Value)
                return false;

            // Limitation Max Trades
            if (chbMaxTrades.Checked && Backtester.ExecutedOrders > nudMaxTrades.Value)
                return false;

            // Limitation Win / Loss ratio
            if (chbWinLossRatio.Checked && Backtester.WinLossRatio < (double)nudWinLossRatio.Value)
                return false;

            // OOS Pattern filter
            if (chbOOSPatternFilter.Checked && chbOutOfSample.Checked)
            {
                int netBalance = Backtester.NetBalance;
                int OOSbalance = Backtester.Balance(barOOS);
                int targetBalance = (int)(OOSbalance * targetBalanceRatio);
                int minBalance    = (int)(targetBalance * (1 - nudOOSPatternPercent.Value / 100));
                if (netBalance < OOSbalance || netBalance < minBalance)
                    return false;
            }

            // Smooth Balance Line
            if (chbSmoothBalanceLines.Checked)
            {
                int checkPoints = (int)nudSmoothBalanceCheckPoints.Value;
                double maxPercentDeviation = (double)(nudSmoothBalancePercent.Value / 100);

                for (int i = 1; i <= checkPoints; i++)
                {
                    int firstBar = Backtester.FirstBar;
                    int bar = Backtester.FirstBar + i * (Data.Bars - firstBar) / (checkPoints + 1);
                    double netBalance   = Backtester.NetMoneyBalance;
                    double startBalance = Backtester.MoneyBalance(firstBar);
                    double checkPointBalance = Backtester.MoneyBalance(bar);
                    double targetBalance = startBalance + i * (netBalance - startBalance) / (checkPoints + 1);
                    double minBalance = targetBalance * (1 - maxPercentDeviation);
                    double maxBalance = targetBalance * (1 + maxPercentDeviation);
                    if (checkPointBalance < minBalance || checkPointBalance > maxBalance)
                        return false;

                    if (Configs.AdditionalStatistics)
                    {
                        // Long balance line
                        netBalance = Backtester.NetLongMoneyBalance;
                        checkPointBalance = Backtester.LongMoneyBalance(bar);
                        startBalance = Backtester.LongMoneyBalance(firstBar);
                        targetBalance = startBalance + i * (netBalance - startBalance) / (checkPoints + 1);
                        minBalance = targetBalance * (1 - maxPercentDeviation);
                        maxBalance = targetBalance * (1 + maxPercentDeviation);
                        if (checkPointBalance < minBalance || checkPointBalance > maxBalance)
                            return false;

                        // Short balance line
                        netBalance = Backtester.NetShortMoneyBalance;
                        checkPointBalance = Backtester.ShortMoneyBalance(bar);
                        startBalance = Backtester.ShortMoneyBalance(firstBar);
                        targetBalance = startBalance + i * (netBalance - startBalance) / (checkPoints + 1);
                        minBalance = targetBalance * (1 - maxPercentDeviation);
                        maxBalance = targetBalance * (1 + maxPercentDeviation);
                        if (checkPointBalance < minBalance || checkPointBalance > maxBalance)
                            return false;
                    }
                }

            }

            return true;
        }

        /// <summary>
        /// Generates a random strategy
        /// </summary>
        void GenerateStrategySlots()
        {
            // Determines the number of slots
            int openFilters = random.Next(lockedEntryFilters, maxOpeningLogicSlots + 1);

            int closeFilters = 0;
            if (lockedExitSlot == null || exitIndicatorsWithFilters.Contains(Data.Strategy.Slot[Data.Strategy.CloseSlot].IndicatorName))
                closeFilters = random.Next(lockedExitFilters, maxClosingLogicSlots + 1);

            // Create a strategy
            Data.Strategy = new Strategy(openFilters, closeFilters);
            Data.Strategy.StrategyName = "Generated";
 
            // Copy the trading sizes
            Data.Strategy.UseAccountPercentEntry = strategyBest.UseAccountPercentEntry;
            Data.Strategy.MaxOpenLots  = strategyBest.MaxOpenLots;
            Data.Strategy.EntryLots    = strategyBest.EntryLots;
            Data.Strategy.AddingLots   = strategyBest.AddingLots;
            Data.Strategy.ReducingLots = strategyBest.ReducingLots;

            int slot = 0;

            // Entry Slot
            if (lockedEntrySlot != null)
            {
                Data.Strategy.Slot[slot] = lockedEntrySlot.Clone();
                if (Data.Strategy.Slot[slot].SlotStatus == StrategySlotStatus.Linked)
                    GenerateIndicatorParameters(slot);
            }
            else
            {
                GenerateIndicatorName(slot);
                GenerateIndicatorParameters(slot);
            }

            // Entry filter slots
            for (int i = 0; i < lockedEntryFilters; i++)
            {
                slot++;
                Data.Strategy.Slot[slot] = aLockedEntryFilter[i].Clone();
                Data.Strategy.Slot[slot].SlotNumber = slot;
                if (Data.Strategy.Slot[slot].SlotStatus == StrategySlotStatus.Linked)
                    GenerateIndicatorParameters(slot);
            }
            for (int i = lockedEntryFilters; i < openFilters; i++)
            {
                slot++;
                GenerateIndicatorName(slot);
                GenerateIndicatorParameters(slot);
            }

            // Exit slot
            if (lockedExitSlot != null)
            {
                slot++;
                Data.Strategy.Slot[slot] = lockedExitSlot.Clone();
                Data.Strategy.Slot[slot].SlotNumber = slot;
                if (Data.Strategy.Slot[slot].SlotStatus == StrategySlotStatus.Linked)
                    GenerateIndicatorParameters(slot);
            }
            else
            {
                slot++;
                GenerateIndicatorName(slot);
                GenerateIndicatorParameters(slot);
            }

            // Exit filter slots
            if (Indicator_Store.ClosingIndicatorsWithClosingFilters.Contains(Data.Strategy.Slot[Data.Strategy.CloseSlot].IndicatorName) && closeFilters > 0)
            {
                for (int i = 0; i < lockedExitFilters; i++)
                {
                    slot++;
                    Data.Strategy.Slot[slot] = aLockedExitFilter[i].Clone();
                    Data.Strategy.Slot[slot].SlotNumber = slot;
                    if (Data.Strategy.Slot[slot].SlotStatus == StrategySlotStatus.Linked)
                        GenerateIndicatorParameters(slot);
                }
                for (int i = lockedExitFilters; i < closeFilters; i++)
                {
                    slot++;
                    GenerateIndicatorName(slot);
                    GenerateIndicatorParameters(slot);
                }
            }

            return;
        }

        /// <summary>
        /// Calculate the indicator in the designated slot
        /// </summary>
        void GenerateIndicatorName(int slot)
        {
            SlotTypes slotType = Data.Strategy.GetSlotType(slot);
            string indicatorName;

            switch (slotType)
            {
                case SlotTypes.Open:
                    do
                    {
                        indicatorName = entryIndicators[random.Next(entryIndicators.Count)];
                    } while (indicatorBlackList.Contains(indicatorName));
                    break;
                case SlotTypes.OpenFilter:
                    do
                    {
                        indicatorName = entryFilterIndicators[random.Next(entryFilterIndicators.Count)];
                    } while (indicatorBlackList.Contains(indicatorName));
                    break;
                case SlotTypes.Close:
                    do
                    {
                        if (Data.Strategy.CloseFilters > 0)
                            indicatorName = exitIndicatorsWithFilters[random.Next(exitIndicatorsWithFilters.Count)];
                        else
                            indicatorName = exitIndicators[random.Next(exitIndicators.Count)];
                    } while (indicatorBlackList.Contains(indicatorName));
                    break;
                case SlotTypes.CloseFilter:
                    do
                    {
                        indicatorName = exitFilterIndicators[random.Next(exitFilterIndicators.Count)];
                    } while (indicatorBlackList.Contains(indicatorName));
                    break;
                default:
                    indicatorName = "Error!";
                    break;
            }

            Data.Strategy.Slot[slot].IndicatorName = indicatorName;

            return;
        }

        /// <summary>
        /// Calculate the indicator in the designated slot
        /// </summary>
        void GenerateIndicatorParameters(int slot)
        {
            string    indicatorName = Data.Strategy.Slot[slot].IndicatorName;
            SlotTypes slotType      = Data.Strategy.GetSlotType(slot);
            Indicator indicator     = Indicator_Store.ConstructIndicator(indicatorName, slotType);

            // List parameters
            foreach (ListParam list in indicator.IndParam.ListParam)
                if (list.Enabled)
                {
                    do
                    {
                        list.Index = random.Next(list.ItemList.Length);
                        list.Text  = list.ItemList[list.Index];
                    } while (list.Caption == "Base price" && (list.Text == "High" || list.Text == "Low"));
                }

            int firstBar = 0;
            do
            {
                // Numeric parameters
                foreach (NumericParam num in indicator.IndParam.NumParam)
                    if (num.Enabled)
                    {
                        if (num.Caption == "Level" && !indicator.IndParam.ListParam[0].Text.Contains("Level"))
                            continue;
                        if (!chbUseDefaultIndicatorValues.Checked)
                        {
                            double step    = Math.Pow(10, -num.Point);
                            double minimum = num.Min;
                            double value   = num.Min;
                            double maximum = num.Max;

                            if (maximum > Data.Bars / 3 && ((num.Caption.ToLower()).Contains("period") ||
                                                            (num.Caption.ToLower()).Contains("shift")  ||
                                                            (num.ToolTip.ToLower()).Contains("period")))
                            {
                                maximum = Math.Max(minimum + step, Data.Bars / 3);
                            }

                            value = minimum + step * random.Next((int)((maximum - minimum) / step));
                            num.Value = Math.Round(value, num.Point);
                        }
                    }

                if (!CalculateIndicator(slotType, indicator))
                    return;

                firstBar = 0;
                foreach (IndicatorComp comp in indicator.Component)
                    if (comp.FirstBar > firstBar)
                        firstBar = comp.FirstBar;

            } while (firstBar > Data.Bars - 10);

            //Set the Data.Strategy
            IndicatorSlot indSlot  = Data.Strategy.Slot[slot];
            indSlot.IndicatorName  = indicator.IndicatorName;
            indSlot.IndParam       = indicator.IndParam;
            indSlot.Component      = indicator.Component;
            indSlot.SeparatedChart = indicator.SeparatedChart;
            indSlot.SpecValue      = indicator.SpecialValues;
            indSlot.MinValue       = indicator.SeparatedChartMinValue;
            indSlot.MaxValue       = indicator.SeparatedChartMaxValue;
            indSlot.IsDefined      = true;

            return;
        }

        /// <summary>
        /// Generate random same and opposite signal action
        /// </summary>
        void GenerateSameOppSignal()
        {
            if (strategyBest.PropertiesStatus == StrategySlotStatus.Locked)
            {
                Data.Strategy.PropertiesStatus = strategyBest.PropertiesStatus;
                Data.Strategy.SameSignalAction = strategyBest.SameSignalAction;
                Data.Strategy.OppSignalAction  = strategyBest.OppSignalAction;
            }
            else
            {
                Data.Strategy.SameSignalAction = (SameDirSignalAction)Enum.GetValues(typeof(SameDirSignalAction)).GetValue(random.Next(3));
                Data.Strategy.OppSignalAction  = (OppositeDirSignalAction)Enum.GetValues(typeof(OppositeDirSignalAction)).GetValue(random.Next(4));

                if (Data.Strategy.Slot[Data.Strategy.CloseSlot].IndicatorName == "Close and Reverse")
                    Data.Strategy.OppSignalAction = OppositeDirSignalAction.Reverse;
            }

            return;
        }

        /// <summary>
        /// Generates the Permanent Stop Loss
        /// </summary>
        void GeneratePermanentSL()
        {
            if (chbPreservPermSL.Checked || strategyBest.PropertiesStatus == StrategySlotStatus.Locked)
            {
                Data.Strategy.UsePermanentSL  = strategyBest.UsePermanentSL;
                Data.Strategy.PermanentSLType = strategyBest.PermanentSLType;
                Data.Strategy.PermanentSL     = strategyBest.PermanentSL;
            }
            else
            {
                bool usePermSL    = random.Next(100) > 30;
                bool changePermSL = random.Next(100) > 50;
                Data.Strategy.UsePermanentSL = usePermSL;
                Data.Strategy.PermanentSLType = PermanentProtectionType.Relative;
                if (usePermSL && changePermSL)
                {
                    int multiplier = Data.InstrProperties.IsFiveDigits ? 50 : 5;
                    Data.Strategy.PermanentSL = multiplier * random.Next(5, 50);
                    //if (random.Next(100) > 80 &&
                    //    (Data.Strategy.SameSignalAction == SameDirSignalAction.Add   || 
                    //    Data.Strategy.SameSignalAction == SameDirSignalAction.Winner ||
                    //    Data.Strategy.OppSignalAction == OppositeDirSignalAction.Reduce))
                    //    Data.Strategy.PermanentSLType = PermanentProtectionType.Absolute;
                }
            }
        }

        /// <summary>
        /// Generates the Permanent Take Profit
        /// </summary>
        void GeneratePermanentTP()
        {
            if (chbPreservPermTP.Checked || strategyBest.PropertiesStatus == StrategySlotStatus.Locked)
            {
                Data.Strategy.UsePermanentTP  = strategyBest.UsePermanentTP;
                Data.Strategy.PermanentTPType = strategyBest.PermanentTPType;
                Data.Strategy.PermanentTP     = strategyBest.PermanentTP;
            }
            else
            {
                bool usePermTP    = random.Next(100) > 30;
                bool changePermTP = random.Next(100) > 50;
                Data.Strategy.UsePermanentTP = usePermTP;
                Data.Strategy.PermanentTPType = PermanentProtectionType.Relative;
                if (usePermTP && changePermTP)
                {
                    int multiplier = Data.InstrProperties.IsFiveDigits ? 50 : 5;
                    Data.Strategy.PermanentTP = multiplier * random.Next(5, 50);
                    //if (random.Next(100) > 80 &&
                    //    (Data.Strategy.SameSignalAction == SameDirSignalAction.Add    ||
                    //    Data.Strategy.SameSignalAction  == SameDirSignalAction.Winner ||
                    //    Data.Strategy.OppSignalAction   == OppositeDirSignalAction.Reduce))
                    //    Data.Strategy.PermanentTPType = PermanentProtectionType.Absolute;
                }
            }
        }

        /// <summary>
        /// Generates Break Even stop.
        /// </summary>
        void GenerateBreakEven()
        {
            if (chbPreservBreakEven.Checked || strategyBest.PropertiesStatus == StrategySlotStatus.Locked)
            {
                Data.Strategy.UseBreakEven = strategyBest.UseBreakEven;
                Data.Strategy.BreakEven    = strategyBest.BreakEven;
            }
            else
            {
                bool useBreakEven    = random.Next(100) > 30;
                bool changeBreakEven = random.Next(100) > 50;
                Data.Strategy.UseBreakEven = useBreakEven;
                if (useBreakEven && changeBreakEven)
                {
                    int multiplier = Data.InstrProperties.IsFiveDigits ? 50 : 5;
                    Data.Strategy.BreakEven = multiplier * random.Next(5, 50);
                }
            }
        }

        /// <summary>
        /// Recalculate all the indicator slots 
        /// </summary>
        void RecalculateSlots()
        {
            foreach (IndicatorSlot indSlot in Data.Strategy.Slot)
            {
                string    indicatorName = indSlot.IndicatorName;
                SlotTypes slotType      = indSlot.SlotType;
                Indicator indicator     = Indicator_Store.ConstructIndicator(indicatorName, slotType);

                indicator.IndParam = indSlot.IndParam;
                indicator.Calculate(slotType);

                indSlot.Component = indicator.Component;
                indSlot.IsDefined = true;
            }

            // Searches the indicators' components to determine the Data.FirstBar 
            Data.FirstBar = Data.Strategy.SetFirstBar();
        }
    }
}
